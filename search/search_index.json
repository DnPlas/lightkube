{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"lightkube Modern lightweight kubernetes module for python NOTICE: This project is still under development and not suitable for production usage. Highlights Simple interface shared across all kubernetes APIs. Extensive type hints to avoid common mistakes and to support autocompletion (tested on PyCharm). Defines models and resources generated from the swagger specifications. Models are defined using standard dataclasses. Lazy instantiation of inner models. Fast startup and small memory footprint as only needed models and resources can be loaded. Automatic handling of pagination when listing resources. Customizable handling of errors when watching resources. This module is powered by httpx . Installation This module requires python >= 3.6 pip install lightkube Usage Read a pod from lightkube import Client from lightkube.resources.core_v1 import Pod client = Client () pod = client . get ( Pod , name = \"my-pod\" , namespace = \"default\" ) print ( pod . namespace . uid ) List nodes from lightkube import Client from lightkube.resources.core_v1 import Node client = Client () for node in client . list ( Node ): print ( node . metadata . name ) Watch deployments from lightkube import Client from lightkube.resources.apps_v1 import Deployment client = Client () for op , dep in client . watch ( Deployment , namespace = \"default\" ): print ( f \" { dep . namespace . name } { dep . spec . replicas } \" ) Create a config map from lightkube.resources.core_v1 import ConfigMap from lightkube.models.meta_v1 import ObjectMeta config = ConfigMap ( metadata = ObjectMeta ( name = 'my-config' , namespace = 'default' ), data = { 'key1' : 'value1' , 'key2' : 'value2' } ) client . create ( config ) Replace the previous config with a different content config . data [ 'key1' ] = 'new value' client . replace ( config ) Patch an existing config patch = { 'metadata' : { 'labels' : { 'app' : 'xyz' }}} client . patch ( ConfigMap , name = 'my-config' , namespace = 'default' , obj = patch ) Delete a namespaced resource client . delete ( ConfigMap , name = 'my-config' , namespace = 'default' ) Scale a deployment from lightkube.resources.apps_v1 import Deployment from lightkube.models.meta_v1 import ObjectMeta from lightkube.models.autoscaling_v1 import ScaleSpec obj = Deployment . Scale ( metadata = ObjectMeta ( name = 'metrics-server' , namespace = 'kube-system' ), spec = ScaleSpec ( replicas = 1 ) ) client . replace ( obj , 'metrics-server' , namespace = 'kube-system' ) Upcoming features Support for async/await Support for loading definitions from yaml files Support for installing a specific version of the kubernetes models","title":"QuickStart"},{"location":"#lightkube","text":"Modern lightweight kubernetes module for python NOTICE: This project is still under development and not suitable for production usage.","title":"lightkube"},{"location":"#highlights","text":"Simple interface shared across all kubernetes APIs. Extensive type hints to avoid common mistakes and to support autocompletion (tested on PyCharm). Defines models and resources generated from the swagger specifications. Models are defined using standard dataclasses. Lazy instantiation of inner models. Fast startup and small memory footprint as only needed models and resources can be loaded. Automatic handling of pagination when listing resources. Customizable handling of errors when watching resources. This module is powered by httpx .","title":"Highlights"},{"location":"#installation","text":"This module requires python >= 3.6 pip install lightkube","title":"Installation"},{"location":"#usage","text":"Read a pod from lightkube import Client from lightkube.resources.core_v1 import Pod client = Client () pod = client . get ( Pod , name = \"my-pod\" , namespace = \"default\" ) print ( pod . namespace . uid ) List nodes from lightkube import Client from lightkube.resources.core_v1 import Node client = Client () for node in client . list ( Node ): print ( node . metadata . name ) Watch deployments from lightkube import Client from lightkube.resources.apps_v1 import Deployment client = Client () for op , dep in client . watch ( Deployment , namespace = \"default\" ): print ( f \" { dep . namespace . name } { dep . spec . replicas } \" ) Create a config map from lightkube.resources.core_v1 import ConfigMap from lightkube.models.meta_v1 import ObjectMeta config = ConfigMap ( metadata = ObjectMeta ( name = 'my-config' , namespace = 'default' ), data = { 'key1' : 'value1' , 'key2' : 'value2' } ) client . create ( config ) Replace the previous config with a different content config . data [ 'key1' ] = 'new value' client . replace ( config ) Patch an existing config patch = { 'metadata' : { 'labels' : { 'app' : 'xyz' }}} client . patch ( ConfigMap , name = 'my-config' , namespace = 'default' , obj = patch ) Delete a namespaced resource client . delete ( ConfigMap , name = 'my-config' , namespace = 'default' ) Scale a deployment from lightkube.resources.apps_v1 import Deployment from lightkube.models.meta_v1 import ObjectMeta from lightkube.models.autoscaling_v1 import ScaleSpec obj = Deployment . Scale ( metadata = ObjectMeta ( name = 'metrics-server' , namespace = 'kube-system' ), spec = ScaleSpec ( replicas = 1 ) ) client . replace ( obj , 'metrics-server' , namespace = 'kube-system' )","title":"Usage"},{"location":"#upcoming-features","text":"Support for async/await Support for loading definitions from yaml files Support for installing a specific version of the kubernetes models","title":"Upcoming features"},{"location":"client/","text":"Interface class lightkube. Client ( config=None , namespace=None , timeout=None , lazy=True ) Creates a new lightkube client parameters config - Instance of KubeConfig . When not set the configuration will be detected automatically with the following order: in cluster config, KUBECONFIG environment variable, ~/.kube/config file. namespace - Default namespace to use. This attribute is used in case namespaced resources are called without defining a namespace. If not specified, the default namespace set in your kube configuration will be used. timeout - Instance of httpx.Timeout . By default all timeouts are set to 10 seconds. Notice that read timeout is ignored when watching changes. lazy - When set, the returned objects will be decoded from the JSON payload in a lazy way, i.e. only when accessed. create ( self , obj , name=None , * , namespace=None ) Creates a new object parameters obj - object to create. This need to be an instance of a resource kind. name - (optional) Required only for sub-resources: Name of the resource to which this object belongs. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). delete ( self , res , name , * , namespace=None ) Delete an object parameters res - Resource kind. name - Name of the object to delete. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). deletecollection ( self , res , * , namespace=None ) Delete all objects of the given kind res - Resource kind. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). get ( self , res , name , * , namespace=None ) Return an object parameters res - Resource kind. name - Name of the object to fetch. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). list ( self , res , * , namespace=None , chunk_size=None , labels=None , fields=None ) Return an iterator of objects matching the selection criteria. parameters res - resource kind. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). chunk_size - (optional) Limit the amount of objects returned for each rest API call. This method will automatically execute all subsequent calls until no more data is available. labels - (optional) Limit the returned objects by labels. More details . fields - (optional) Limit the returned objects by fields. More details . namespace Return the default namespace that will be used when a namespace has not been specified patch ( self , res , name , obj , * , namespace=None , patch_type= ) Patch an object. parameters res - Resource kind. name - Name of the object to patch. obj - patch object. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). patch_type - (optional) Type of patch to execute. Default PatchType.STRATEGIC . replace ( self , obj , name=None , * , namespace=None ) Replace an existing resource. parameters obj - new object. This need to be an instance of a resource kind. name - (optional) Required only for sub-resources: Name of the resource to which this object belongs. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). watch ( self , res , * , namespace=None , labels=None , fields=None , server_timeout=None , resource_version=None , on_error= ) Watch changes to objects parameters res - resource kind. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). labels - (optional) Limit the returned objects by labels. More details . fields - (optional) Limit the returned objects by fields. More details . server_timeout - (optional) Server side timeout in seconds to close a watch request. This method will automatically create a new request whenever the backend close the connection without errors. resource_version - (optional) When set, only modification events following this version will be returned. on_error - (optional) Function that control what to do in case of errors. The default implementation will raise any error. namespace parameter All API calls for namespaced resources will need to refer to a specific namespace. By default the namespace provided in the kubeconfig file is used. This default can be overridden when instantiating the client class with a different value. You can also specify a specific namespace for a single call using the namespace parameter. The methods create or replace will respect the namespace defined in the object to be created except if this is missing or explictly overriden using the method's namespace parameter. Override rules summary: client.method(..., namespace=..) [ obj.metadata.namespace ] (Only when calling create or replace ) Client(..., namespace=...) kubernetes config file List or watch objects in all namespaces The methods list and watch can also return objects for all namespaces using namespace='*' .","title":"Interface"},{"location":"client/#interface","text":"class lightkube. Client ( config=None , namespace=None , timeout=None , lazy=True ) Creates a new lightkube client parameters config - Instance of KubeConfig . When not set the configuration will be detected automatically with the following order: in cluster config, KUBECONFIG environment variable, ~/.kube/config file. namespace - Default namespace to use. This attribute is used in case namespaced resources are called without defining a namespace. If not specified, the default namespace set in your kube configuration will be used. timeout - Instance of httpx.Timeout . By default all timeouts are set to 10 seconds. Notice that read timeout is ignored when watching changes. lazy - When set, the returned objects will be decoded from the JSON payload in a lazy way, i.e. only when accessed. create ( self , obj , name=None , * , namespace=None ) Creates a new object parameters obj - object to create. This need to be an instance of a resource kind. name - (optional) Required only for sub-resources: Name of the resource to which this object belongs. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). delete ( self , res , name , * , namespace=None ) Delete an object parameters res - Resource kind. name - Name of the object to delete. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). deletecollection ( self , res , * , namespace=None ) Delete all objects of the given kind res - Resource kind. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). get ( self , res , name , * , namespace=None ) Return an object parameters res - Resource kind. name - Name of the object to fetch. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). list ( self , res , * , namespace=None , chunk_size=None , labels=None , fields=None ) Return an iterator of objects matching the selection criteria. parameters res - resource kind. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). chunk_size - (optional) Limit the amount of objects returned for each rest API call. This method will automatically execute all subsequent calls until no more data is available. labels - (optional) Limit the returned objects by labels. More details . fields - (optional) Limit the returned objects by fields. More details . namespace Return the default namespace that will be used when a namespace has not been specified patch ( self , res , name , obj , * , namespace=None , patch_type= ) Patch an object. parameters res - Resource kind. name - Name of the object to patch. obj - patch object. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). patch_type - (optional) Type of patch to execute. Default PatchType.STRATEGIC . replace ( self , obj , name=None , * , namespace=None ) Replace an existing resource. parameters obj - new object. This need to be an instance of a resource kind. name - (optional) Required only for sub-resources: Name of the resource to which this object belongs. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). watch ( self , res , * , namespace=None , labels=None , fields=None , server_timeout=None , resource_version=None , on_error= ) Watch changes to objects parameters res - resource kind. namespace - (optional) Name of the namespace containing the object (Only for namespaced resources). labels - (optional) Limit the returned objects by labels. More details . fields - (optional) Limit the returned objects by fields. More details . server_timeout - (optional) Server side timeout in seconds to close a watch request. This method will automatically create a new request whenever the backend close the connection without errors. resource_version - (optional) When set, only modification events following this version will be returned. on_error - (optional) Function that control what to do in case of errors. The default implementation will raise any error.","title":"Interface"},{"location":"client/#namespace-parameter","text":"All API calls for namespaced resources will need to refer to a specific namespace. By default the namespace provided in the kubeconfig file is used. This default can be overridden when instantiating the client class with a different value. You can also specify a specific namespace for a single call using the namespace parameter. The methods create or replace will respect the namespace defined in the object to be created except if this is missing or explictly overriden using the method's namespace parameter. Override rules summary: client.method(..., namespace=..) [ obj.metadata.namespace ] (Only when calling create or replace ) Client(..., namespace=...) kubernetes config file","title":"namespace parameter"},{"location":"client/#list-or-watch-objects-in-all-namespaces","text":"The methods list and watch can also return objects for all namespaces using namespace='*' .","title":"List or watch objects in all namespaces"},{"location":"example/","text":"ControllerRevision class lightkube.models.apps_v1. ControllerRevision ( revision , apiVersion=None , data=None , kind=None , metadata=None ) ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers. parameters revision int - Revision indicates the revision of the state represented by Data. apiVersion str - (optional) APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api- conventions.md#resources data runtime.RawExtension - (optional) Data is the serialized representation of the state. kind str - (optional) Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api- conventions.md#types-kinds metadata meta_v1.ObjectMeta - (optional) Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api- conventions.md#metadata Deployment class lightkube.models.apps_v1. Deployment ( apiVersion=None , kind=None , metadata=None , spec=None , status=None ) Deployment enables declarative updates for Pods and ReplicaSets. parameters apiVersion str - (optional) APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api- conventions.md#resources kind str - (optional) Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api- conventions.md#types-kinds metadata meta_v1.ObjectMeta - (optional) Standard object metadata. spec DeploymentSpec - (optional) Specification of the desired behavior of the Deployment. status DeploymentStatus - (optional) Most recently observed status of the Deployment.","title":"Example"},{"location":"example/#controllerrevision","text":"class lightkube.models.apps_v1. ControllerRevision ( revision , apiVersion=None , data=None , kind=None , metadata=None ) ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers. parameters revision int - Revision indicates the revision of the state represented by Data. apiVersion str - (optional) APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api- conventions.md#resources data runtime.RawExtension - (optional) Data is the serialized representation of the state. kind str - (optional) Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api- conventions.md#types-kinds metadata meta_v1.ObjectMeta - (optional) Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api- conventions.md#metadata","title":"ControllerRevision"},{"location":"example/#deployment","text":"class lightkube.models.apps_v1. Deployment ( apiVersion=None , kind=None , metadata=None , spec=None , status=None ) Deployment enables declarative updates for Pods and ReplicaSets. parameters apiVersion str - (optional) APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api- conventions.md#resources kind str - (optional) Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api- conventions.md#types-kinds metadata meta_v1.ObjectMeta - (optional) Standard object metadata. spec DeploymentSpec - (optional) Specification of the desired behavior of the Deployment. status DeploymentStatus - (optional) Most recently observed status of the Deployment.","title":"Deployment"},{"location":"resources-and-models/","text":"Resources & Models Resources Kubernetes API provides access to several resource kinds organized by version and API group. Lightkube represents such resources using classes that can be found inside the package lightkube.resources . Resources are organized in modules where the name follow the convention {group}_{version} . For example the group apps on version v1 includes the resource kind Deployment and it can be accessed as follow from lightkube.resources.apps_v1 import Deployment . Resource classes can be used to call the lightkube client methods or to instantiate the corresponding objects. >>> from lightkube import Client >>> from lightkube.resources.apps_v1 import Deployment >>> client = Client () >>> dep = client . get ( Deployment , name = \"my-deo\" ) >>> type ( dep ) < class ' lightkube . resources . apps_v1 . Deployment '> Subresources Some kubernetes resources provide extra subresources like /status . Subresources can be found as attributes of the corresponding resource class. For example Deployment provides Deployment.Status and Deployment.Scale . Similar to resources, subresources can be used directly with the lightkube client. Models The package lightkube.models provides models for all schemas defined in the kubernetes API. The models are split in modules in a similar way to resources (i.e. the module name match {group}_{version} ). All models are defined using standard python dataclasses and are used to create or retrieve kubernetes objects. >>> from lightkube.models.meta_v1 import ObjectMeta >>> ObjectMeta ( name = 'test' , namespace = 'default' ) ObjectMeta ( annotations = None , clusterName = None , creationTimestamp = None , deletionGracePeriodSeconds = None , deletionTimestamp = None , finalizers = None , generateName = None , generation = None , initializers = None , labels = None , managedFields = None , name = 'test' , namespace = 'default' , ownerReferences = None , resourceVersion = None , selfLink = None , uid = None ) Resources are also subclasses of models but they hold extra information regarding the way the resource can be accessed. The lightkube client need such information, so will only accept resources or resource instances as parameters. Versioning Resource and Models are part of a separate python package named lightkube-models . This package follows the version of the corresponding kubernetes API: {k8s-version}.{release} For example the package version 1.15.6.1 match kubernetes version 1.15.6 at release 1. Depending on the Kubernetes server in use, the appropriate version should be selected as follow lightkube-models>=1.15,<1.16 .","title":"Resources & Models"},{"location":"resources-and-models/#resources-models","text":"","title":"Resources &amp; Models"},{"location":"resources-and-models/#resources","text":"Kubernetes API provides access to several resource kinds organized by version and API group. Lightkube represents such resources using classes that can be found inside the package lightkube.resources . Resources are organized in modules where the name follow the convention {group}_{version} . For example the group apps on version v1 includes the resource kind Deployment and it can be accessed as follow from lightkube.resources.apps_v1 import Deployment . Resource classes can be used to call the lightkube client methods or to instantiate the corresponding objects. >>> from lightkube import Client >>> from lightkube.resources.apps_v1 import Deployment >>> client = Client () >>> dep = client . get ( Deployment , name = \"my-deo\" ) >>> type ( dep ) < class ' lightkube . resources . apps_v1 . Deployment '>","title":"Resources"},{"location":"resources-and-models/#subresources","text":"Some kubernetes resources provide extra subresources like /status . Subresources can be found as attributes of the corresponding resource class. For example Deployment provides Deployment.Status and Deployment.Scale . Similar to resources, subresources can be used directly with the lightkube client.","title":"Subresources"},{"location":"resources-and-models/#models","text":"The package lightkube.models provides models for all schemas defined in the kubernetes API. The models are split in modules in a similar way to resources (i.e. the module name match {group}_{version} ). All models are defined using standard python dataclasses and are used to create or retrieve kubernetes objects. >>> from lightkube.models.meta_v1 import ObjectMeta >>> ObjectMeta ( name = 'test' , namespace = 'default' ) ObjectMeta ( annotations = None , clusterName = None , creationTimestamp = None , deletionGracePeriodSeconds = None , deletionTimestamp = None , finalizers = None , generateName = None , generation = None , initializers = None , labels = None , managedFields = None , name = 'test' , namespace = 'default' , ownerReferences = None , resourceVersion = None , selfLink = None , uid = None ) Resources are also subclasses of models but they hold extra information regarding the way the resource can be accessed. The lightkube client need such information, so will only accept resources or resource instances as parameters.","title":"Models"},{"location":"resources-and-models/#versioning","text":"Resource and Models are part of a separate python package named lightkube-models . This package follows the version of the corresponding kubernetes API: {k8s-version}.{release} For example the package version 1.15.6.1 match kubernetes version 1.15.6 at release 1. Depending on the Kubernetes server in use, the appropriate version should be selected as follow lightkube-models>=1.15,<1.16 .","title":"Versioning"},{"location":"selectors/","text":"Selectors The methods Client.list and Client.watch allows to filter results on server side using the attributes labels and fields . Label Selectors The attribute labels represents a set of requirements computed against the object labels that need to be satisfied in order for an object to be matched. The parameter value is as a dictionary where key represent a label key and the value represent a matching operation. This is equivalent to use the Kubernetes API parameters labelSelector . For more details regarding label selectors see the official Kubernetes documentation . This is the list of possible matching operations: Operator Signature Example Alternative syntax Equal equal(value) {\"env\": equal(\"prod\")} {\"env\": \"prod\"} Not equal not_equal(value) {\"env\": not_equal(\"prod\")} - Exists exists() {\"env\": exists()} {\"env\": None} Not exists not_exists() {\"env\": not_exists()} - In in_(sequence) {\"env\": in_([\"prod\", \"dev\"])} {\"env\": [\"prod\", \"dev\"]} Not in not_in(sequence) {\"env\": not_in([\"prod\", \"dev\"])} - Examples Match objects having a label with key env and value prod : labels = { \"env\" : \"prod\" } Match objects having env == prod and app == myapp : labels = { \"env\" : \"prod\" , \"app\" : \"myapp\" } Match objects having env == prod and a label with key app : labels = { \"env\" : \"prod\" , \"app\" : None } Match objects having env == prod or env == dev : labels = { \"env\" : ( \"prod\" , \"dev\" )} The following example uses the operators functions: from lightkube import operators as op Match objects not having a label key app : labels = { \"app\" : op . not_exists ()} Match objects where env != prod : labels = { \"env\" : op . not_equal ( \"prod\" )} Match objects where env != prod and env != dev : labels = { \"env\" : op . not_in ([ \"prod\" , \"dev\" ])} Field Selectors The attribute fields let you select Kubernetes resources based on the value of one or more resource fields. This is equivalent to use the Kubernetes API parameters fieldSelector . For more details regarding field selectors see the official Kubernetes documentation . Note Each resource support a specific (and very limited) set of fields that can be used in the selector. Note The valid operations for field selectors are only \"equal\", \"not equal\" and \"not in\". Examples Match objects where the name is myobj : fields = { \"metadata.name\" : \"myobj\" } Match objects where status phase is \"Pending\": fields = { \"status.phase\" : \"Pending\" } Match objects if they are not in the \"default\" namespace: fields = { \"metadata.namespace\" : op . not_equal ( \"default\" )}","title":"Selectors"},{"location":"selectors/#selectors","text":"The methods Client.list and Client.watch allows to filter results on server side using the attributes labels and fields .","title":"Selectors"},{"location":"selectors/#label-selectors","text":"The attribute labels represents a set of requirements computed against the object labels that need to be satisfied in order for an object to be matched. The parameter value is as a dictionary where key represent a label key and the value represent a matching operation. This is equivalent to use the Kubernetes API parameters labelSelector . For more details regarding label selectors see the official Kubernetes documentation . This is the list of possible matching operations: Operator Signature Example Alternative syntax Equal equal(value) {\"env\": equal(\"prod\")} {\"env\": \"prod\"} Not equal not_equal(value) {\"env\": not_equal(\"prod\")} - Exists exists() {\"env\": exists()} {\"env\": None} Not exists not_exists() {\"env\": not_exists()} - In in_(sequence) {\"env\": in_([\"prod\", \"dev\"])} {\"env\": [\"prod\", \"dev\"]} Not in not_in(sequence) {\"env\": not_in([\"prod\", \"dev\"])} -","title":"Label Selectors"},{"location":"selectors/#examples","text":"Match objects having a label with key env and value prod : labels = { \"env\" : \"prod\" } Match objects having env == prod and app == myapp : labels = { \"env\" : \"prod\" , \"app\" : \"myapp\" } Match objects having env == prod and a label with key app : labels = { \"env\" : \"prod\" , \"app\" : None } Match objects having env == prod or env == dev : labels = { \"env\" : ( \"prod\" , \"dev\" )} The following example uses the operators functions: from lightkube import operators as op Match objects not having a label key app : labels = { \"app\" : op . not_exists ()} Match objects where env != prod : labels = { \"env\" : op . not_equal ( \"prod\" )} Match objects where env != prod and env != dev : labels = { \"env\" : op . not_in ([ \"prod\" , \"dev\" ])}","title":"Examples"},{"location":"selectors/#field-selectors","text":"The attribute fields let you select Kubernetes resources based on the value of one or more resource fields. This is equivalent to use the Kubernetes API parameters fieldSelector . For more details regarding field selectors see the official Kubernetes documentation . Note Each resource support a specific (and very limited) set of fields that can be used in the selector. Note The valid operations for field selectors are only \"equal\", \"not equal\" and \"not in\".","title":"Field Selectors"},{"location":"selectors/#examples_1","text":"Match objects where the name is myobj : fields = { \"metadata.name\" : \"myobj\" } Match objects where status phase is \"Pending\": fields = { \"status.phase\" : \"Pending\" } Match objects if they are not in the \"default\" namespace: fields = { \"metadata.namespace\" : op . not_equal ( \"default\" )}","title":"Examples"}]}